1) Differnece between Mutex and semaphores
	- Mutexes are very useful to protect data (critical section) from race conditions. Semaphores are usually used to synchronize threads more than to protect critical section.
	-  The reason for that is that semaphores do not have any ownership. A mutex can be released only by the thread that acquired it (a thread gets ownership of a mutex when waking from a mutex wait). 		However for semaphores any thread (or main) can initialize them to locked (0), and any thread can wait on them (blocks on 0 and decrements its value after) or post to them (increments its value)

2) Here are the rules for debugging stack corruption:

    If a crash is observed when a function returns, this might be due to stack corruption. The return address on the stack might have been corrupted by stack operations of called functions.
    Crash after an interrupt service routine returns might also be caused by stack corruption.
    Stack corruption can also be suspected when a passed parameter seems to have a value different from the one passed by the calling function. 
    When a stack corruption is detected, one should look at the local variables in the called and calling functions to look for possible sources of memory corruption. Check array and pointer declarations for sources of errors.
    Sometimes stray corruption of a processors registers might also be due to a stack corruption. If a register gets corrupted due to no reason, one possibility is that an offending thread or program corrupted the register context on the stack. When the register is restored as a part of a context switch, the task crashes.
    Corruption in heap can trickle down to the stack.
    Stack overflow takes place when a programs function nesting exceeds the stack allocated to the program. This can cause a stack area or heap area corruption. (Depends upon who attempts to access the corrupted memory first, a heap operation or stack operation).

3) What is the difference between a thread and a process?

	1. Threads are easier to create than processes since they 
	don't require a separate address space.
	2. Multithreading requires careful programming since threads 
	share data strucures that should only be modified by one thread
	at a time.  Unlike threads, processes don't share the same 
	address space.
	3.  Threads are considered lightweight because they use far 
	less resources than processes.
	4.  Processes are independent of each other.  Threads, since they 
	share the same address space are interdependent, so caution 
	must be taken so that different threads don't step on each other.  
	This is really another way of stating #2 above.
	5.  A process can consist of multiple threads.
	6.The processes and threads are independent sequences of execution, the typical difference is that threads run in a shared memory space, while processes run in separate memory spaces.
	A process has a self contained execution environment that means it has a complete, private set of basic run time resources purticularly each process has its own memory space. Threads exist within a		process and every process has at least one thread.
	Each process provides the resources needed to execute a program. Each process is started with a single thread, known as the primary thread. A process can have multiple threads in addition to the pr		imary thread.
	On a multiprocessor system, multiple processes can be executed in parallel. Multiple threads of control can exploit the true parallelism possible on multiprocessor systems.
	Threads have direct access to the data segment of its process but a processes have their own copy of the data segment of the parent process.
	Changes to the main thread may affect the behavior of the other threads of the process while changes to the parent process does not affect child processes.
	Processes are heavily dependent on system resources available while threads require minimal amounts of resource, so a process is considered as heavyweight while a thread is termed as a lightweight 		process.
